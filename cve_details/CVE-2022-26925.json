{
    "Modified": "2022-10-07T18:08:00",
    "Published": "2022-05-10T21:15:00",
    "access": {
        "authentication": "NONE",
        "complexity": "MEDIUM",
        "vector": "NETWORK"
    },
    "assigner": "secure@microsoft.com",
    "capec": [
        {
            "id": "94",
            "name": "Man in the Middle Attack",
            "prerequisites": "There are two components communicating with each other. An attacker is able to identify the nature and mechanism of communication between the two target components. An attacker can eavesdrop on the communication between the target components. Strong mutual authentication is not used between the two target components yielding opportunity for attacker interposition. The communication occurs in clear (not encrypted) or with insufficient and spoofable encryption.",
            "related_weakness": [
                "287",
                "290",
                "294",
                "300",
                "593",
                "724"
            ],
            "solutions": "Get your Public Key signed by a Certificate Authority Encrypt your communication using cryptography (SSL,...) Use Strong mutual authentication to always fully authenticate both ends of any communications channel. Exchange public keys using a secure channel",
            "summary": "This type of attack targets the communication between two components (typically client and server). The attacker places himself in the communication channel between the two components. Whenever one component attempts to communicate with the other (data flow, authentication challenges, etc.), the data first goes to the attacker, who has the opportunity to observe or alter it, and it is then passed on to the other component as if it was never observed. This interposition is transparent leaving the two compromised components unaware of the potential corruption or leakage of their communications. The potential for Man-in-the-Middle attacks yields an implicit lack of trust in communication or identify between two components. MITM attacks differ from sniffing attacks since they often modify the communications prior to delivering it to the intended recipient. These attacks also differ from interception attacks since they may forward the sender's original unmodified data, after copying it, instead of keeping it for themselves."
        },
        {
            "id": "473",
            "name": "Signature Spoof",
            "prerequisites": "The victim or victim system is dependent upon a cryptographic signature-based verification system for validation of one or more security events or actions. The validation can be bypassed via an attacker-provided signature that makes it appear that the legitimate authoritative or reputable source provided the signature.",
            "related_weakness": [
                "20",
                "290",
                "327"
            ],
            "solutions": "",
            "summary": "An attacker generates a message or datablock that causes the recipient to believe that the message or datablock was generated and cryptographically signed by an authoritative or reputable source, misleading a victim or victim operating system into performing malicious actions."
        },
        {
            "id": "459",
            "name": "Creating a Rogue Certification Authority Certificate",
            "prerequisites": "Certification Authority is using the MD5 hash function to generate the certificate hash to be signed",
            "related_weakness": [
                "290",
                "295",
                "327"
            ],
            "solutions": "Certification Authorities need to stop using the weak collision prone MD5 hashing algorithm to hash the certificates that they are about to sign. Instead they should be using stronger hashing functions such as SHA-256 or SHA-512.",
            "summary": "An adversary exploits a weakness in the MD5 hash algorithm (weak collision resistance) to generate a certificate signing request (CSR) that contains collision blocks in the \"to be signed\" part. The adversary specially crafts two different, but valid X.509 certificates that when hashed with the MD5 algorithm would yield the same value. The adversary then sends the CSR for one of the certificates to the Certification Authority which uses the MD5 hashing algorithm. That request is completely valid and the Certificate Authority issues an X.509 certificate to the adversary which is signed with its private key. An adversary then takes that signed blob and inserts it into another X.509 certificate that the attacker generated. Due to the MD5 collision, both certificates, though different, hash to the same value and so the signed blob works just as well in the second certificate. The net effect is that the adversary's second X.509 certificate, which the Certification Authority has never seen, is now signed and validated by that Certification Authority. To make the attack more interesting, the second certificate could be not just a regular certificate, but rather itself a signing certificate. Thus the adversary is able to start their own Certification Authority that is anchored in its root of trust in the legitimate Certification Authority that has signed the attackers' first X.509 certificate. If the original Certificate Authority was accepted by default by browsers, so will now the Certificate Authority set up by the adversary and of course any certificates that it signs. So the adversary is now able to generate any SSL certificates to impersonate any web server, and the user's browser will not issue any warning to the victim. This can be used to compromise HTTPS communications and other types of systems where PKI and X.509 certificates may be used (e.g., VPN, IPSec)."
        },
        {
            "id": "21",
            "name": "Exploitation of Trusted Credentials",
            "prerequisites": "Server software must rely on weak session IDs proof and/or verification schemes",
            "related_weakness": [
                "290",
                "302",
                "346",
                "384",
                "539",
                "6",
                "602",
                "642",
                "664"
            ],
            "solutions": "Design: utilize strong federated identity such as SAML to encrypt and sign identity tokens in transit. Implementation: Use industry standards session key generation mechanisms that utilize high amount of entropy to generate the session key. Many standard web and application servers will perform this task on your behalf. Implementation: If the session identifier is used for authentication, such as in the so-called single sign on use cases, then ensure that it is protected at the same level of assurance as authentication tokens. Implementation: If the web or application server supports it, then encrypting and/or signing the session ID (such as cookie) can protect the ID if intercepted. Design: Use strong session identifiers that are protected in transit and at rest. Implementation: Utilize a session timeout for all sessions, for example 20 minutes. If the user does not explicitly logout, the server terminates their session after this period of inactivity. If the user logs back in then a new session key is generated. Implementation: Verify of authenticity of all session IDs at runtime.",
            "summary": "Attacks on session IDs and resource IDs take advantage of the fact that some software accepts user input without verifying its authenticity. For example, a message queuing system that allows service requesters to post messages to its queue through an open channel (such as anonymous FTP), authorization is done through checking group or role membership contained in the posted message. However, there is no proof that the message itself, the information in the message (such group or role membership), or indeed the process that wrote the message to the queue are authentic and authorized to do so. Many server side processes are vulnerable to these attacks because the server to server communications have not been analyzed from a security perspective or the processes \"trust\" other systems because they are behind a firewall. In a similar way servers that use easy to guess or spoofable schemes for representing digital identity can also be vulnerable. Such systems frequently use schemes without cryptography and digital signatures (or with broken cryptography). Session IDs may be guessed due to insufficient randomness, poor protection (passed in the clear), lack of integrity (unsigned), or improperly correlation with access control policy enforcement points. Exposed configuration and properties files that contain system passwords, database connection strings, and such may also give an attacker an edge to identify these identifiers. The net result is that spoofing and impersonation is possible leading to an attacker's ability to break authentication, authorization, and audit controls on the system."
        },
        {
            "id": "461",
            "name": "Web Services API Signature Forgery Leveraging Hash Function Extension Weakness",
            "prerequisites": "Web services check the signature of the API calls Authentication tokens / secrets are shared between the server and the legitimate client The API call signature is generated by concatenating the parameter list with the shared secret and hashing the result. An iterative hash function like MD5 and SHA1 is used. An attacker is able to intercept or in some other way gain access to the information passed between the legitimate client and the server in order to retrieve the hash value and length of the original message. The communication channel between the client and the server is not secured via channel security such as TLS",
            "related_weakness": [
                "290",
                "328"
            ],
            "solutions": "Design: Use a secure message authentication code (MAC) function such as an HMAC-SHA1",
            "summary": "When web services require callees to authenticate, they sometimes issue a token / secret to the caller that the caller is to use to sign their web service calls. In one such scheme the caller when constructing a request would concatenate all of the parameters passed to the web service with the provided authentication token and then generate a hash of the concatenated string (e.g., MD5, SHA1, etc.). That hash then forms the signature that is passed to the web service which is used on the server side to verify the origin authenticity and integrity of the message. There is a practical attack against an authentication scheme of this nature that makes use of the hash function extension / padding weakness. Leveraging this weakness, an attacker, who does not know the secret token, is able to modify the parameters passed to the web service by generating their own call and still generate a legitimate signature hash. For instance, consider the message to be passed to the web service is M (this message includes the parameters passed to the web service concatenated with the secret token / key bytes). The message M is hashed and that hash is passed to the web service and is used for authentication. The attacker does not know M, but can see Hash (M) and Length (M). The attacker can then compute Hash (M || Padding (M) || M') for any M'. The attacker does not know the entire message M, specifically the attacker does not know the secret bytes, but that does not matter. The attacker is still able to sign their own message M' and make the called web service verify the integrity of the message without an error. Because of the iterative design of the hash function, it is possible, from only the hash of a message and its length, to compute the hash of longer messages that start with the initial message and include the padding required for the initial message to reach a multiple of 512 bits. It is important to note that the attack not limited to MD5 and will work just as well with another hash function like SHA1."
        },
        {
            "id": "476",
            "name": "Signature Spoofing by Misrepresentation",
            "prerequisites": "Recipient is using signature verification software that does not clearly indicate potential homographs in the signer identity.Recipient is using signature verification software that contains a parsing vulnerability, or allows control characters in the signer identity field, such that a signature is mistakenly displayed as valid and from a known or authoritative signer.",
            "related_weakness": [
                "290"
            ],
            "solutions": "Ensure the application is using parsing and data display techniques that will accurately display control characters, international symbols and markings, and ultimately recognize potential homograph attacks.",
            "summary": "An attacker exploits a weakness in the parsing or display code of the recipient software to generate a data blob containing a supposedly valid signature, but the signer's identity is falsely represented, which can lead to the attacker manipulating the recipient software or its victim user to perform compromising actions."
        },
        {
            "id": "59",
            "name": "Session Credential Falsification through Prediction",
            "prerequisites": "The target host uses session IDs to keep track of the users. Session IDs are used to control access to resources. The session IDs used by the target host are predictable. For example, the session IDs are generated using predictable information (e.g., time).",
            "related_weakness": [
                "200",
                "285",
                "290",
                "330",
                "331",
                "346",
                "384",
                "488",
                "539",
                "6",
                "693",
                "719"
            ],
            "solutions": "Use a strong source of randomness to generate a session ID. Use adequate length session IDs Do not use information available to the user in order to generate session ID (e.g., time). Ideas for creating random numbers are offered by Eastlake [RFC1750] Encrypt the session ID if you expose it to the user. For instance session ID can be stored in a cookie in encrypted format.",
            "summary": "This attack targets predictable session ID in order to gain privileges. The attacker can predict the session ID used during a transaction to perform spoofing and session hijacking."
        },
        {
            "id": "22",
            "name": "Exploiting Trust in Client",
            "prerequisites": "Server software must rely on client side formatted and validated values, and not reinforce these checks on the server side.",
            "related_weakness": [
                "20",
                "200",
                "287",
                "290",
                "693"
            ],
            "solutions": "Design: Ensure that client process and/or message is authenticated so that anonymous communications and/or messages are not accepted by the system. Design: Do not rely on client validation or encoding for security purposes. Design: Utilize digital signatures to increase authentication assurance. Design: Utilize two factor authentication to increase authentication assurance. Implementation: Perform input validation for all remote content.",
            "summary": "An attack of this type exploits vulnerabilities in client/server communication channel authentication and data integrity. It leverages the implicit trust a server places in the client, or more importantly, that which the server believes is the client. An attacker executes this type of attack by communicating directly with the server where the server believes it is communicating only with a valid client. There are numerous variations of this type of attack."
        },
        {
            "id": "60",
            "name": "Reusing Session IDs (aka Session Replay)",
            "prerequisites": "The target host uses session IDs to keep track of the users. Session IDs are used to control access to resources. The session IDs used by the target host are not well protected from session theft.",
            "related_weakness": [
                "200",
                "285",
                "290",
                "294",
                "346",
                "384",
                "488",
                "539",
                "664",
                "732"
            ],
            "solutions": "Always invalidate a session ID after the user logout. Setup a session time out for the session IDs. Protect the communication between the client and server. For instance it is best practice to use SSL to mitigate man in the middle attack. Do not code send session ID with GET method, otherwise the session ID will be copied to the URL. In general avoid writing session IDs in the URLs. URLs can get logged in log files, which are vulnerable to an attacker. Encrypt the session data associated with the session ID. Use multifactor authentication.",
            "summary": "This attack targets the reuse of valid session ID to spoof the target system in order to gain privileges. The attacker tries to reuse a stolen session ID used previously during a transaction to perform spoofing and session hijacking. Another name for this type of attack is Session Replay."
        }
    ],
    "cvss": 4.3,
    "cvss-time": "2022-10-07T18:08:00",
    "cvss-vector": "AV:N/AC:M/Au:N/C:N/I:P/A:N",
    "cwe": "CWE-290",
    "id": "CVE-2022-26925",
    "impact": {
        "availability": "NONE",
        "confidentiality": "NONE",
        "integrity": "PARTIAL"
    },
    "last-modified": "2022-10-07T18:08:00",
    "references": [
        "https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2022-26925"
    ],
    "summary": "Windows LSA Spoofing Vulnerability.",
    "vulnerable_configuration": [
        {
            "id": "cpe:2.3:o:microsoft:windows_10:-:*:*:*:*:*:x64:*",
            "title": "cpe:2.3:o:microsoft:windows_10:-:*:*:*:*:*:x64:*"
        },
        {
            "id": "cpe:2.3:o:microsoft:windows_10:1607:*:*:*:*:*:x86:*",
            "title": "cpe:2.3:o:microsoft:windows_10:1607:*:*:*:*:*:x86:*"
        },
        {
            "id": "cpe:2.3:o:microsoft:windows_server_2008:r2:sp1:*:*:*:*:x64:*",
            "title": "cpe:2.3:o:microsoft:windows_server_2008:r2:sp1:*:*:*:*:x64:*"
        },
        {
            "id": "cpe:2.3:o:microsoft:windows_7:-:sp1:*:*:*:*:x86:*",
            "title": "cpe:2.3:o:microsoft:windows_7:-:sp1:*:*:*:*:x86:*"
        },
        {
            "id": "cpe:2.3:o:microsoft:windows_server_2012:r2:*:*:*:*:*:*:*",
            "title": "cpe:2.3:o:microsoft:windows_server_2012:r2:*:*:*:*:*:*:*"
        },
        {
            "id": "cpe:2.3:o:microsoft:windows_server_2016:-:*:*:*:*:*:*:*",
            "title": "cpe:2.3:o:microsoft:windows_server_2016:-:*:*:*:*:*:*:*"
        },
        {
            "id": "cpe:2.3:o:microsoft:windows_10:-:*:*:*:*:*:x86:*",
            "title": "cpe:2.3:o:microsoft:windows_10:-:*:*:*:*:*:x86:*"
        },
        {
            "id": "cpe:2.3:o:microsoft:windows_10:1607:*:*:*:*:*:x64:*",
            "title": "cpe:2.3:o:microsoft:windows_10:1607:*:*:*:*:*:x64:*"
        },
        {
            "id": "cpe:2.3:o:microsoft:windows_rt_8.1:-:*:*:*:*:*:*:*",
            "title": "cpe:2.3:o:microsoft:windows_rt_8.1:-:*:*:*:*:*:*:*"
        },
        {
            "id": "cpe:2.3:o:microsoft:windows_7:-:sp1:*:*:*:*:x64:*",
            "title": "cpe:2.3:o:microsoft:windows_7:-:sp1:*:*:*:*:x64:*"
        },
        {
            "id": "cpe:2.3:o:microsoft:windows_server_2012:-:*:*:*:*:*:*:*",
            "title": "cpe:2.3:o:microsoft:windows_server_2012:-:*:*:*:*:*:*:*"
        },
        {
            "id": "cpe:2.3:o:microsoft:windows_8.1:-:*:*:*:*:*:x64:*",
            "title": "cpe:2.3:o:microsoft:windows_8.1:-:*:*:*:*:*:x64:*"
        },
        {
            "id": "cpe:2.3:o:microsoft:windows_server_2019:-:*:*:*:*:*:*:*",
            "title": "cpe:2.3:o:microsoft:windows_server_2019:-:*:*:*:*:*:*:*"
        },
        {
            "id": "cpe:2.3:o:microsoft:windows_10:1809:*:*:*:*:*:x64:*",
            "title": "cpe:2.3:o:microsoft:windows_10:1809:*:*:*:*:*:x64:*"
        },
        {
            "id": "cpe:2.3:o:microsoft:windows_10:1809:*:*:*:*:*:x86:*",
            "title": "cpe:2.3:o:microsoft:windows_10:1809:*:*:*:*:*:x86:*"
        },
        {
            "id": "cpe:2.3:o:microsoft:windows_10:1809:*:*:*:*:*:arm64:*",
            "title": "cpe:2.3:o:microsoft:windows_10:1809:*:*:*:*:*:arm64:*"
        },
        {
            "id": "cpe:2.3:o:microsoft:windows_8.1:-:*:*:*:*:*:x86:*",
            "title": "cpe:2.3:o:microsoft:windows_8.1:-:*:*:*:*:*:x86:*"
        },
        {
            "id": "cpe:2.3:o:microsoft:windows_server_2008:r2:sp1:*:*:*:*:x86:*",
            "title": "cpe:2.3:o:microsoft:windows_server_2008:r2:sp1:*:*:*:*:x86:*"
        },
        {
            "id": "cpe:2.3:o:microsoft:windows_10:1909:*:*:*:*:*:x64:*",
            "title": "cpe:2.3:o:microsoft:windows_10:1909:*:*:*:*:*:x64:*"
        },
        {
            "id": "cpe:2.3:o:microsoft:windows_10:1909:*:*:*:*:*:arm64:*",
            "title": "cpe:2.3:o:microsoft:windows_10:1909:*:*:*:*:*:arm64:*"
        },
        {
            "id": "cpe:2.3:o:microsoft:windows_10:1909:*:*:*:*:*:x86:*",
            "title": "cpe:2.3:o:microsoft:windows_10:1909:*:*:*:*:*:x86:*"
        },
        {
            "id": "cpe:2.3:o:microsoft:windows_10:20h2:*:*:*:*:*:x64:*",
            "title": "cpe:2.3:o:microsoft:windows_10:20h2:*:*:*:*:*:x64:*"
        },
        {
            "id": "cpe:2.3:o:microsoft:windows_10:20h2:*:*:*:*:*:arm64:*",
            "title": "cpe:2.3:o:microsoft:windows_10:20h2:*:*:*:*:*:arm64:*"
        },
        {
            "id": "cpe:2.3:o:microsoft:windows_10:20h2:*:*:*:*:*:x86:*",
            "title": "cpe:2.3:o:microsoft:windows_10:20h2:*:*:*:*:*:x86:*"
        },
        {
            "id": "cpe:2.3:o:microsoft:windows_server_2008:sp2:*:*:*:*:*:x64:*",
            "title": "cpe:2.3:o:microsoft:windows_server_2008:sp2:*:*:*:*:*:x64:*"
        },
        {
            "id": "cpe:2.3:o:microsoft:windows_server_2008:sp2:*:*:*:*:*:x86:*",
            "title": "cpe:2.3:o:microsoft:windows_server_2008:sp2:*:*:*:*:*:x86:*"
        },
        {
            "id": "cpe:2.3:o:microsoft:windows_10:21h1:*:*:*:*:*:x64:*",
            "title": "cpe:2.3:o:microsoft:windows_10:21h1:*:*:*:*:*:x64:*"
        },
        {
            "id": "cpe:2.3:o:microsoft:windows_11:-:*:*:*:*:*:arm64:*",
            "title": "cpe:2.3:o:microsoft:windows_11:-:*:*:*:*:*:arm64:*"
        },
        {
            "id": "cpe:2.3:o:microsoft:windows_11:-:*:*:*:*:*:x64:*",
            "title": "cpe:2.3:o:microsoft:windows_11:-:*:*:*:*:*:x64:*"
        },
        {
            "id": "cpe:2.3:o:microsoft:windows_10:21h1:*:*:*:*:*:arm64:*",
            "title": "cpe:2.3:o:microsoft:windows_10:21h1:*:*:*:*:*:arm64:*"
        },
        {
            "id": "cpe:2.3:o:microsoft:windows_10:21h1:*:*:*:*:*:x86:*",
            "title": "cpe:2.3:o:microsoft:windows_10:21h1:*:*:*:*:*:x86:*"
        },
        {
            "id": "cpe:2.3:o:microsoft:windows_server:2022:*:*:*:*:*:*:*",
            "title": "cpe:2.3:o:microsoft:windows_server:2022:*:*:*:*:*:*:*"
        },
        {
            "id": "cpe:2.3:o:microsoft:windows_10:21h2:*:*:*:*:*:arm64:*",
            "title": "cpe:2.3:o:microsoft:windows_10:21h2:*:*:*:*:*:arm64:*"
        },
        {
            "id": "cpe:2.3:o:microsoft:windows_10:21h2:*:*:*:*:*:x64:*",
            "title": "cpe:2.3:o:microsoft:windows_10:21h2:*:*:*:*:*:x64:*"
        },
        {
            "id": "cpe:2.3:o:microsoft:windows_10:21h2:*:*:*:*:*:x86:*",
            "title": "cpe:2.3:o:microsoft:windows_10:21h2:*:*:*:*:*:x86:*"
        }
    ],
    "vulnerable_configuration_cpe_2_2": [],
    "vulnerable_product": [
        "cpe:2.3:o:microsoft:windows_10:-:*:*:*:*:*:x64:*",
        "cpe:2.3:o:microsoft:windows_10:1607:*:*:*:*:*:x86:*",
        "cpe:2.3:o:microsoft:windows_server_2008:r2:sp1:*:*:*:*:x64:*",
        "cpe:2.3:o:microsoft:windows_7:-:sp1:*:*:*:*:x86:*",
        "cpe:2.3:o:microsoft:windows_server_2012:r2:*:*:*:*:*:*:*",
        "cpe:2.3:o:microsoft:windows_server_2016:-:*:*:*:*:*:*:*",
        "cpe:2.3:o:microsoft:windows_10:-:*:*:*:*:*:x86:*",
        "cpe:2.3:o:microsoft:windows_10:1607:*:*:*:*:*:x64:*",
        "cpe:2.3:o:microsoft:windows_rt_8.1:-:*:*:*:*:*:*:*",
        "cpe:2.3:o:microsoft:windows_7:-:sp1:*:*:*:*:x64:*",
        "cpe:2.3:o:microsoft:windows_server_2012:-:*:*:*:*:*:*:*",
        "cpe:2.3:o:microsoft:windows_8.1:-:*:*:*:*:*:x64:*",
        "cpe:2.3:o:microsoft:windows_server_2019:-:*:*:*:*:*:*:*",
        "cpe:2.3:o:microsoft:windows_10:1809:*:*:*:*:*:x64:*",
        "cpe:2.3:o:microsoft:windows_10:1809:*:*:*:*:*:x86:*",
        "cpe:2.3:o:microsoft:windows_10:1809:*:*:*:*:*:arm64:*",
        "cpe:2.3:o:microsoft:windows_8.1:-:*:*:*:*:*:x86:*",
        "cpe:2.3:o:microsoft:windows_server_2008:r2:sp1:*:*:*:*:x86:*",
        "cpe:2.3:o:microsoft:windows_10:1909:*:*:*:*:*:x64:*",
        "cpe:2.3:o:microsoft:windows_10:1909:*:*:*:*:*:arm64:*",
        "cpe:2.3:o:microsoft:windows_10:1909:*:*:*:*:*:x86:*",
        "cpe:2.3:o:microsoft:windows_10:20h2:*:*:*:*:*:x64:*",
        "cpe:2.3:o:microsoft:windows_10:20h2:*:*:*:*:*:arm64:*",
        "cpe:2.3:o:microsoft:windows_10:20h2:*:*:*:*:*:x86:*",
        "cpe:2.3:o:microsoft:windows_server_2008:sp2:*:*:*:*:*:x64:*",
        "cpe:2.3:o:microsoft:windows_server_2008:sp2:*:*:*:*:*:x86:*",
        "cpe:2.3:o:microsoft:windows_10:21h1:*:*:*:*:*:x64:*",
        "cpe:2.3:o:microsoft:windows_11:-:*:*:*:*:*:arm64:*",
        "cpe:2.3:o:microsoft:windows_11:-:*:*:*:*:*:x64:*",
        "cpe:2.3:o:microsoft:windows_10:21h1:*:*:*:*:*:arm64:*",
        "cpe:2.3:o:microsoft:windows_10:21h1:*:*:*:*:*:x86:*",
        "cpe:2.3:o:microsoft:windows_server:2022:*:*:*:*:*:*:*",
        "cpe:2.3:o:microsoft:windows_10:21h2:*:*:*:*:*:arm64:*",
        "cpe:2.3:o:microsoft:windows_10:21h2:*:*:*:*:*:x64:*",
        "cpe:2.3:o:microsoft:windows_10:21h2:*:*:*:*:*:x86:*"
    ]
}