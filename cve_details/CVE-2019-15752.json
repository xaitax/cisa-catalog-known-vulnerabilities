{
    "Modified": "2020-08-31T14:15:00",
    "Published": "2019-08-28T21:15:00",
    "access": {
        "authentication": "NONE",
        "complexity": "MEDIUM",
        "vector": "NETWORK"
    },
    "assigner": "cve@mitre.org",
    "capec": [
        {
            "id": "61",
            "name": "Session Fixation",
            "prerequisites": "Session identifiers that remain unchanged when the privilege levels change. Permissive session management mechanism that accepts random user-generated session identifiers Predictable session identifiers",
            "related_weakness": [
                "361",
                "384",
                "664",
                "732"
            ],
            "solutions": "Use a strict session management mechanism that only accepts locally generated session identifiers: This prevents attackers from fixating session identifiers of their own choice. Regenerate and destroy session identifiers when there is a change in the level of privilege: This ensures that even though a potential victim may have followed a link with a fixated identifier, a new one is issued when the level of privilege changes. Use session identifiers that are difficult to guess or brute-force: One way for the attackers to obtain valid session identifiers is by brute-forcing or guessing them. By choosing session identifiers that are sufficiently random, brute-forcing or guessing becomes very difficult.",
            "summary": "The attacker induces a client to establish a session with the target software using a session identifier provided by the attacker. Once the user successfully authenticates to the target software, the attacker uses the (now privileged) session identifier in their own transactions. This attack leverages the fact that the target software either relies on client-generated session identifiers or maintains the same session identifiers after privilege elevation."
        },
        {
            "id": "642",
            "name": "Replace Binaries",
            "prerequisites": "The attacker must be able to place the malicious binary on the target machine.",
            "related_weakness": [
                "732"
            ],
            "solutions": "Insure that binaries commonly used by the system have the correct file permissions. Set operating system policies that restrict privilege elevation of non-Administrators. Use auditing tools to observe changes to system services.",
            "summary": "Adversaries know that certain binaries will be regularly executed as part of normal processing. If these binaries are not protected with the appropriate file system permissions, it could be possible to replace them with malware. This malware might be executed at higher system permission levels. A variation of this pattern is to discover self-extracting installation packages that unpack binaries to directories with weak file permissions which it does not clean up appropriately. These binaries can be replaced by malware, which can then be executed."
        },
        {
            "id": "62",
            "name": "Cross Site Request Forgery",
            "prerequisites": "",
            "related_weakness": [
                "306",
                "352",
                "664",
                "716",
                "732"
            ],
            "solutions": "Use cryptographic tokens to associate a request with a specific action. The token can be regenerated at every request so that if a request with an invalid token is encountered, it can be reliably discarded. The token is considered invalid if it arrived with a request other than the action it was supposed to be associated with. Although less reliable, the use of the optional HTTP Referrer header can also be used to determine whether an incoming request was actually one that the user is authorized for, in the current context. Additionally, the user can also be prompted to confirm an action every time an action concerning potentially sensitive data is invoked. This way, even if the attacker manages to get the user to click on a malicious link and request the desired action, the user has a chance to recover by denying confirmation. This solution is also implicitly tied to using a second factor of authentication before performing such actions. In general, every request must be checked for the appropriate authentication token as well as authorization in the current session context.",
            "summary": "An attacker crafts malicious web links and distributes them (via web pages, email, etc.), typically in a targeted manner, hoping to induce users to click on the link and execute the malicious action against some third-party application. If successful, the action embedded in the malicious link will be processed and accepted by the targeted application with the users' privilege level. This type of attack leverages the persistence and implicit trust placed in user session cookies by many web applications today. In such an architecture, once the user authenticates to an application and a session cookie is created on the user's system, all following transactions for that session are authenticated using that cookie including potential actions initiated by an attacker and simply \"riding\" the existing session cookie."
        },
        {
            "id": "234",
            "name": "Hijacking a privileged process",
            "prerequisites": "The targeted process or operating system must contain a bug that allows attackers to hijack the targeted process.",
            "related_weakness": [
                "648",
                "732"
            ],
            "solutions": "",
            "summary": "An attacker gains control of a process that is assigned elevated privileges in order to execute arbitrary code with those privileges. Some processes are assigned elevated privileges on an operating system, usually through association with a particular user, group, or role. If an attacker can hijack this process, they will be able to assume its level of privilege in order to execute their own code. Processes can be hijacked through improper handling of user input (for example, a buffer overflow or certain types of injection attacks) or by utilizing system utilities that support process control that have been inadequately secured."
        },
        {
            "id": "17",
            "name": "Using Malicious Files",
            "prerequisites": "System's configuration must allow an attacker to directly access executable files or upload files to execute. This means that any access control system that is supposed to mediate communications between the subject and the object is set incorrectly or assumes a benign environment.",
            "related_weakness": [
                "264",
                "270",
                "272",
                "275",
                "282",
                "285",
                "59",
                "693",
                "732"
            ],
            "solutions": "Design: Enforce principle of least privilege Design: Run server interfaces with a non-root account and/or utilize chroot jails or other configuration techniques to constrain privileges even if attacker gains some limited access to commands. Implementation: Perform testing such as pen-testing and vulnerability scanning to identify directories, programs, and interfaces that grant direct access to executables.",
            "summary": "An attack of this type exploits a system's configuration that allows an attacker to either directly access an executable file, for example through shell access; or in a possible worst case allows an attacker to upload a file and then execute it. Web servers, ftp servers, and message oriented middleware systems which have many integration points are particularly vulnerable, because both the programmers and the administrators must be in synch regarding the interfaces and the correct privileges for each interface."
        },
        {
            "id": "180",
            "name": "Exploiting Incorrectly Configured Access Control Security Levels",
            "prerequisites": "The target must apply access controls, but incorrectly configure them. However, not all incorrect configurations can be exploited by an attacker. If the incorrect configuration applies too little security to some functionality, then the attacker may be able to exploit it if the access control would be the only thing preventing an attacker's access and it no longer does so. If the incorrect configuration applies too much security, it must prevent legitimate activity and the attacker must be able to force others to require this activity..",
            "related_weakness": [
                "732"
            ],
            "solutions": "Design: Configure the access control correctly.",
            "summary": "An attacker exploits a weakness in the configuration of access controls and is able to bypass the intended protection that these measures guard against and thereby obtain unauthorized access to the system or network. Sensitive functionality should always be protected with access controls. However configuring all but the most trivial access control systems can be very complicated and there are many opportunities for mistakes. If an attacker can learn of incorrectly configured access security settings, they may be able to exploit this in an attack. Most commonly, attackers would take advantage of controls that provided too little protection for sensitive activities in order to perform actions that should be denied to them. In some circumstances, an attacker may be able to take advantage of overly restrictive access control policies, initiating denial of services (if an application locks because it unexpectedly failed to be granted access) or causing other legitimate actions to fail due to security. The latter class of attacks, however, is usually less severe and easier to detect than attacks based on inadequate security restrictions. This attack pattern differs from CAPEC 1, \"Accessing Functionality Not Properly Constrained by ACLs\" in that the latter describes attacks where sensitive functionality lacks access controls, where, in this pattern, the access control is present, but incorrectly configured."
        },
        {
            "id": "206",
            "name": "Signing Malicious Code",
            "prerequisites": "The targeted developer must use a signing key to sign code bundles. (Note that not doing this is not a defense - it only means that the attacker does not need to steal the signing key before forging code bundles in the developer's name.)",
            "related_weakness": [
                "732"
            ],
            "solutions": "",
            "summary": "The attacker extracts credentials used for code signing from a production environment and then uses these credentials to sign malicious content with the developer's key. Many developers use signing keys to sign code or hashes of code. When users or applications verify the signatures are accurate they are led to believe that the code came from the owner of the signing key and that the code has not been modified since the signature was applied. If the attacker has extracted the signing credentials then they can use those credentials to sign their own code bundles. Users or tools that verify the signatures attached to the code will likely assume the code came from the legitimate developer and install or run the code, effectively allowing the attacker to execute arbitrary code on the victim's computer."
        },
        {
            "id": "1",
            "name": "Accessing Functionality Not Properly Constrained by ACLs",
            "prerequisites": "The application must be navigable in a manner that associates elements (subsections) of the application with ACLs. The various resources, or individual URLs, must be somehow discoverable by the attacker The administrator must have forgotten to associate an ACL or has associated an inappropriately permissive ACL with a particular navigable resource.",
            "related_weakness": [
                "276",
                "285",
                "434",
                "693",
                "721",
                "732"
            ],
            "solutions": "In a more general setting, the administrator must mark every resource besides the ones supposed to be exposed to the user as accessible by a role impossible for the user to assume. The default security setting must be to deny access and then grant access only to those resources intended by business logic.",
            "summary": "In applications, particularly web applications, access to functionality is mitigated by an authorization framework. This framework maps Access Control Lists (ACLs) to elements of the application's functionality; particularly URL's for web apps. In the case that the administrator failed to specify an ACL for a particular element, an attacker may be able to access it with impunity. An attacker with the ability to access functionality not properly constrained by ACLs can obtain sensitive information and possibly compromise the entire application. Such an attacker can access resources that must be available only to users at a higher privilege level, can access management sections of the application, or can run queries for data that they otherwise not supposed to."
        },
        {
            "id": "122",
            "name": "Privilege Abuse",
            "prerequisites": "The target must have misconfigured their access control mechanisms such that sensitive information, which should only be accessible to more trusted users, remains accessible to less trusted users. The adversary must have access to the target, albeit with an account that is less privileged than would be appropriate for the targeted resources.",
            "related_weakness": [
                "269",
                "732"
            ],
            "solutions": "",
            "summary": "An adversary is able to exploit features of the target that should be reserved for privileged users or administrators but are exposed to use by lower or non-privileged accounts. Access to sensitive information and functionality must be controlled to ensure that only authorized users are able to access these resources. If access control mechanisms are absent or misconfigured, a user may be able to access resources that are intended only for higher level users. An adversary may be able to exploit this to utilize a less trusted account to gain information and perform activities reserved for more trusted accounts. This attack differs from privilege escalation and other privilege stealing attacks in that the adversary never actually escalates their privileges but instead is able to use a lesser degree of privilege to access resources that should be (but are not) reserved for higher privilege accounts. Likewise, the adversary does not exploit trust or subvert systems - all control functionality is working as configured but the configuration does not adequately protect sensitive resources at an appropriate level."
        },
        {
            "id": "127",
            "name": "Directory Indexing",
            "prerequisites": "The target must be misconfigured to return a list of a directory's content when it receives a request that ends in a directory name rather than a file name. The adversary must be able to control the path that is requested of the target. The administrator must have failed to properly configure an ACL or has associated an overly permissive ACL with a particular directory. The server version or patch level must not inherently prevent known directory listing attacks from working.",
            "related_weakness": [
                "276",
                "285",
                "288",
                "424",
                "425",
                "693",
                "721",
                "732"
            ],
            "solutions": "1. Using blank index.html: putting blank index.html simply prevent directory listings from displaying to site visitors. 2. Preventing with .htaccess in Apache web server: In .htaccess, write \"Options-indexes\". 3. Suppressing error messages: using error 403 \"Forbidden\" message exactly like error 404 \"Not Found\" message.",
            "summary": "An adversary crafts a request to a target that results in the target listing/indexing the content of a directory as output. One common method of triggering directory contents as output is to construct a request containing a path that terminates in a directory name rather than a file name since many applications are configured to provide a list of the directory's contents when such a request is received. An adversary can use this to explore the directory tree on a target as well as learn the names of files. This can often end up revealing test files, backup files, temporary files, hidden files, configuration files, user accounts, script contents, as well as naming conventions, all of which can be used by an attacker to mount additional attacks."
        },
        {
            "id": "60",
            "name": "Reusing Session IDs (aka Session Replay)",
            "prerequisites": "The target host uses session IDs to keep track of the users. Session IDs are used to control access to resources. The session IDs used by the target host are not well protected from session theft.",
            "related_weakness": [
                "200",
                "285",
                "290",
                "294",
                "346",
                "384",
                "488",
                "539",
                "664",
                "732"
            ],
            "solutions": "Always invalidate a session ID after the user logout. Setup a session time out for the session IDs. Protect the communication between the client and server. For instance it is best practice to use SSL to mitigate man in the middle attack. Do not code send session ID with GET method, otherwise the session ID will be copied to the URL. In general avoid writing session IDs in the URLs. URLs can get logged in log files, which are vulnerable to an attacker. Encrypt the session data associated with the session ID. Use multifactor authentication.",
            "summary": "This attack targets the reuse of valid session ID to spoof the target system in order to gain privileges. The attacker tries to reuse a stolen session ID used previously during a transaction to perform spoofing and session hijacking. Another name for this type of attack is Session Replay."
        }
    ],
    "cvss": 9.3,
    "cvss-time": "2020-08-31T14:15:00",
    "cvss-vector": "AV:N/AC:M/Au:N/C:C/I:C/A:C",
    "cwe": "CWE-732",
    "id": "CVE-2019-15752",
    "impact": {
        "availability": "COMPLETE",
        "confidentiality": "COMPLETE",
        "integrity": "COMPLETE"
    },
    "last-modified": "2020-08-31T14:15:00",
    "references": [
        "http://packetstormsecurity.com/files/157404/Docker-Credential-Wincred.exe-Privilege-Escalation.html",
        "https://lists.apache.org/thread.html/rf1bbc0ea4a9f014cf94df9a12a6477d24a27f52741dbc87f2fd52ff2@%3Cissues.geode.apache.org%3E",
        "https://medium.com/@morgan.henry.roman/elevation-of-privilege-in-docker-for-windows-2fd8450b478e"
    ],
    "refmap": {
        "misc": [
            "http://packetstormsecurity.com/files/157404/Docker-Credential-Wincred.exe-Privilege-Escalation.html",
            "https://medium.com/@morgan.henry.roman/elevation-of-privilege-in-docker-for-windows-2fd8450b478e"
        ],
        "mlist": [
            "[geode-issues] 20200831 [jira] [Created] (GEODE-8471) Dependency security issues in geode-core-1.12"
        ]
    },
    "summary": "Docker Desktop Community Edition before 2.1.0.1 allows local users to gain privileges by placing a Trojan horse docker-credential-wincred.exe file in %PROGRAMDATA%\\DockerDesktop\\version-bin\\ as a low-privilege user, and then waiting for an admin or service user to authenticate with Docker, restart Docker, or run 'docker login' to force the command.",
    "vulnerable_configuration": [
        {
            "id": "cpe:2.3:a:docker:docker:1.12.0:*:*:*:community:*:*:*",
            "title": "cpe:2.3:a:docker:docker:1.12.0:*:*:*:community:*:*:*"
        },
        {
            "id": "cpe:2.3:a:docker:docker:1.12.1:*:*:*:community:*:*:*",
            "title": "cpe:2.3:a:docker:docker:1.12.1:*:*:*:community:*:*:*"
        },
        {
            "id": "cpe:2.3:a:docker:docker:1.12.3:*:*:*:community:*:*:*",
            "title": "cpe:2.3:a:docker:docker:1.12.3:*:*:*:community:*:*:*"
        },
        {
            "id": "cpe:2.3:a:docker:docker:1.12.4:*:*:*:community:*:*:*",
            "title": "cpe:2.3:a:docker:docker:1.12.4:*:*:*:community:*:*:*"
        },
        {
            "id": "cpe:2.3:a:docker:docker:1.12.5:*:*:*:community:*:*:*",
            "title": "cpe:2.3:a:docker:docker:1.12.5:*:*:*:community:*:*:*"
        },
        {
            "id": "cpe:2.3:a:docker:docker:1.13.0:*:*:*:community:*:*:*",
            "title": "cpe:2.3:a:docker:docker:1.13.0:*:*:*:community:*:*:*"
        },
        {
            "id": "cpe:2.3:a:docker:docker:1.13.1:*:*:*:community:*:*:*",
            "title": "cpe:2.3:a:docker:docker:1.13.1:*:*:*:community:*:*:*"
        },
        {
            "id": "cpe:2.3:a:docker:docker:2.0.0.0:*:*:*:community:*:*:*",
            "title": "cpe:2.3:a:docker:docker:2.0.0.0:*:*:*:community:*:*:*"
        },
        {
            "id": "cpe:2.3:a:docker:docker:2.0.0.2:*:*:*:community:*:*:*",
            "title": "cpe:2.3:a:docker:docker:2.0.0.2:*:*:*:community:*:*:*"
        },
        {
            "id": "cpe:2.3:a:docker:docker:2.0.0.3:*:*:*:community:*:*:*",
            "title": "cpe:2.3:a:docker:docker:2.0.0.3:*:*:*:community:*:*:*"
        },
        {
            "id": "cpe:2.3:o:microsoft:windows:-:*:*:*:*:*:*:*",
            "title": "cpe:2.3:o:microsoft:windows:-:*:*:*:*:*:*:*"
        }
    ],
    "vulnerable_configuration_cpe_2_2": [],
    "vulnerable_product": [
        "cpe:2.3:a:docker:docker:1.12.0:*:*:*:community:*:*:*",
        "cpe:2.3:a:docker:docker:1.12.1:*:*:*:community:*:*:*",
        "cpe:2.3:a:docker:docker:1.12.3:*:*:*:community:*:*:*",
        "cpe:2.3:a:docker:docker:1.12.4:*:*:*:community:*:*:*",
        "cpe:2.3:a:docker:docker:1.12.5:*:*:*:community:*:*:*",
        "cpe:2.3:a:docker:docker:1.13.0:*:*:*:community:*:*:*",
        "cpe:2.3:a:docker:docker:1.13.1:*:*:*:community:*:*:*",
        "cpe:2.3:a:docker:docker:2.0.0.0:*:*:*:community:*:*:*",
        "cpe:2.3:a:docker:docker:2.0.0.2:*:*:*:community:*:*:*",
        "cpe:2.3:a:docker:docker:2.0.0.3:*:*:*:community:*:*:*"
    ]
}